import { useEffect, useRef, useState } from "react";
import { socket } from "../../App";
import { useStateContext } from "../../ContextProvider";
import axios from "../../axiosConfig";
import MessageFromMe from "./MessageFromMe";
import MessageFromOther from "./MessageFromOther";
import { toast } from "react-toastify";
import { GoArrowDown } from "react-icons/go";
import { CircularProgress, IconButton } from "@mui/material";
import { IoIosCloseCircleOutline } from "react-icons/io";

const ChatMessages = ({ searchQuery }) => {
  const [messages, setMessages] = useState({ data: [] });
  const [loading, setLoading] = useState(false);
  const [scrollToBottom, setScrollToBottom] = useState(false);
  const [recipientsUpdated, setRecipientsUpdated] = useState(false);
  const [newMessages, setNewMessages] = useState(0);
  const { User, setReceivedMessages, setMessageBeingSent, setReplyMessage, replyMessage } =
    useStateContext();
  const messagesContainerRef = useRef();

  // FILTER LOGIC (For display only)
  const getDisplayMessages = () => {
    if (!messages?.data) return [];
    if (!searchQuery) return messages.data;

    return messages.data.filter((msg) => {
      if (msg.type === "date-separator") return false;
      const contentMatch = msg.content?.toLowerCase().includes(searchQuery.toLowerCase());
      const fileMatch = msg.fileName?.toLowerCase().includes(searchQuery.toLowerCase());
      const senderMatch = msg.from?.displayName?.toLowerCase().includes(searchQuery.toLowerCase());
      return contentMatch || fileMatch || senderMatch;
    });
  };

  const displayMessages = getDisplayMessages();

  // --- NEW PROFESSIONAL DOWNLOAD LOGIC ---
  const handleDownloadUserChat = (targetUserId, targetUserName) => {
    // 1. Filter the FULL history (messages.data) not just what's displayed
    const userMessages = messages.data.filter(msg => 
      msg.from?._id === targetUserId && msg.type !== "date-separator"
    );

    if (userMessages.length === 0) {
      toast.info(`No message history found for ${targetUserName}.`);
      return;
    }

    // 2. Format the Text File
    let textContent = "";
    textContent += "=================================================================\n";
    textContent += "                        USER CHAT REPORT                         \n";
    textContent += "=================================================================\n\n";
    textContent += `Target User  : ${targetUserName}\n`;
    textContent += `Export Date  : ${new Date().toLocaleString()}\n`;
    textContent += `Total Texts  : ${userMessages.length}\n`;
    textContent += `Generated By : ${User?.displayName || "Admin"}\n\n`;
    
    textContent += "-----------------------------------------------------------------\n";
    textContent += "  TIMESTAMP               |  MESSAGE CONTENT                     \n";
    textContent += "-----------------------------------------------------------------\n";

    userMessages.forEach(msg => {
       // Format Date: "Feb 09, 06:41 PM"
       const dateObj = new Date(msg.createdAt);
       const dateStr = dateObj.toLocaleDateString('en-US', { month: 'short', day: '2-digit' });
       const timeStr = dateObj.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
       const timestamp = `${dateStr}, ${timeStr}`.padEnd(25); // Align columns

       let content = msg.content || "";
       if (msg.type === "deleted") content = "[Message Deleted]";
       if (msg.file) content += ` [Attachment: ${msg.fileName}]`;
       
       // Handle multi-line messages for cleaner alignment
       const contentLines = content.split('\n');
       
       textContent += `${timestamp} |  ${contentLines[0]}\n`;
       
       // Indent subsequent lines of the same message
       if (contentLines.length > 1) {
         for (let i = 1; i < contentLines.length; i++) {
            textContent += `${" ".repeat(25)} |  ${contentLines[i]}\n`;
         }
       }
       textContent += "\n"; // Space between messages
    });

    textContent += "=================================================================\n";
    textContent += "                       END OF REPORT                             \n";
    textContent += "=================================================================\n";

    // 3. Trigger Download
    const blob = new Blob([textContent], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${targetUserName.replace(/\s+/g, '_')}_Chat_History.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    toast.success(`Exported ${userMessages.length} messages from ${targetUserName}`);
  };

  const setChatMessagesGrouped = (data) => {
    const groupedMessages = {};
    data?.forEach((msg) => {
      const date = new Date(msg.createdAt).toLocaleDateString();
      const message = { ...msg, date };
      if (!groupedMessages[date]) groupedMessages[date] = [];
      groupedMessages[date].push(message);
    });

    const messagesWithDateSeparators = [];
    for (let i in groupedMessages) {
      messagesWithDateSeparators.push({
        type: "date-separator",
        date: groupedMessages[i][0]?.date,
      });
      messagesWithDateSeparators.push(...groupedMessages[i]);
    }
    setMessages({ data: messagesWithDateSeparators, scroll: true });
  };

  const fetchMessages = async () => {
    try {
      setLoading(true);
      const response = await axios.get("/messages");
      setChatMessagesGrouped(response?.data?.data);
      setLoading(false);
    } catch (error) {
      console.log(error);
      toast.error("Something went wrong", { position: "top-right", theme: "light" });
    }
  };

  const handleReloadChat = () => {
    setRecipientsUpdated(false);
    fetchMessages();
  };

  useEffect(() => { if (!scrollToBottom) setNewMessages(0); }, [scrollToBottom]);

  useEffect(() => {
    fetchMessages();
    if (socket) {
      socket.on("chat_message", (newMessage) => {
        if (newMessage?.from?._id === User?._id) {
          setMessages(({ data }) => ({ data: [...data, newMessage], scroll: true }));
        } else if (User?.role === 1 && newMessage?.from?._id !== User?._id) {
          setNewMessages((prev) => prev + 1);
          setMessages(({ data }) => ({ data: [...data, newMessage], scroll: false }));
        }
      });
      socket.on("chat_recipients_updated", () => handleReloadChat());
      socket.on("chat_message_deleted", (id) => {
        setMessages(({ data }) => {
          const messagesCopy = [...data];
          const messageIdx = data?.findIndex((m) => m?._id === id);
          if (messageIdx >= 0) {
            messagesCopy[messageIdx] = { ...messagesCopy[messageIdx], type: "deleted", content: "This message was deleted", recipients: [], image: "" };
          }
          return { data: messagesCopy, scroll: false };
        });
      });
    }
  }, []);

  const scrollBottom = () => {
    if (messagesContainerRef.current) {
      messagesContainerRef.current.scrollTop = messagesContainerRef.current.scrollHeight;
    }
  };

  useEffect(() => {
    if (messages?.scroll && !searchQuery) {
      if (messagesContainerRef.current) {
        setTimeout(() => scrollBottom(), 0);
        setReceivedMessages(0);
        setMessageBeingSent(false);
        socket.emit("chat_mark_read", User?._id);
      }
    }
  }, [messages, searchQuery]);

  const handleScroll = (e) => {
    if (e.currentTarget.scrollTop < e.currentTarget.scrollHeight - 100 - e.currentTarget.offsetHeight) {
      setScrollToBottom(true);
    } else {
      setScrollToBottom(false);
    }
  };

  return (
    <div className="chat-body relative pb-1 min-h-[73vh] h-[73vh] bg-white w-full">
      <div
        ref={messagesContainerRef}
        onScroll={handleScroll}
        className={`overflow-y-auto overflow-x-hidden w-full pb-14 scroll-smooth pt-4 px-4 h-full flex flex-col ${recipientsUpdated && "select-none pointer-events-none"}`}
      >
        {loading ? (
          <div className="flex items-center h-full justify-center"><CircularProgress style={{ color: "grey" }} size={28} /></div>
        ) : displayMessages.length ? (
          displayMessages.map((message) => {
            if (message?.type === "date-separator") {
              return (
                <div key={message?._id || Math.random()} className="flex my-4 items-center justify-center">
                  <small className="px-2 text-xs text-gray-500 font-medium">{message?.date}</small>
                </div>
              );
            } else if (message?.from?._id === User?._id) {
              return <MessageFromMe noMenu={message?.type === "deleted"} messageData={message} key={message?._id} />;
            } else {
              return (
                <MessageFromOther 
                  noMenu={message?.type === "deleted"} 
                  messageData={message} 
                  key={message?._id} 
                  // Pass the new download function
                  onDownloadChat={handleDownloadUserChat}
                />
              );
            }
          })
        ) : (
          <div className="text-xl flex items-center h-full justify-center text-slate-300">{searchQuery ? "No matches found" : "No messages yet"}</div>
        )}
        {!!scrollToBottom && (
          <div onClick={scrollBottom} className="bg-white border border-gray-200 z-50 shadow-lg w-max p-2 absolute right-10 bottom-20 cursor-pointer rounded-full flex items-center justify-center hover:bg-gray-50">
            <GoArrowDown size={20} className="text-gray-600" />
            {!!newMessages && <div className="absolute z-[100] -top-1 flex justify-center items-center -right-1 rounded-full text-white w-[20px] h-[20px] bg-blue-600 shadow-lg text-xs">{newMessages}</div>}
          </div>
        )}
      </div>
      {replyMessage && (
        <div className="absolute max-h-[130px] rounded mx-auto w-[90%] overflow-y-scroll bottom-20 bg-white border border-gray-200 shadow-lg left-0 right-0 z-10">
          <div className="flex flex-col p-3 w-full pr-8"><p className="text-sm text-gray-600 truncate">{replyMessage?.content}</p></div>
          <div className="absolute right-2 top-2 cursor-pointer"><IconButton onClick={() => setReplyMessage(null)}><IoIosCloseCircleOutline size={20} /></IconButton></div>
        </div>
      )}
    </div>
  );
};

export default ChatMessages;